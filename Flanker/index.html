<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FlankerGame</title>
  <style>
    :root{
      --bg:#000;--fg:#fff;--muted:#bbb;--accent:#888;--warn:#e74c3c;--ok:#2ecc71;
      --maxw:1000px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    #app{min-height:100%;display:grid;place-items:center}
    .screen{width:100%;max-width:var(--maxw);padding:24px;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;gap:24px;text-align:center}
    .btn{background:#444;border:2px solid #fff;color:#fff;padding:12px 20px;border-radius:10px;cursor:pointer;font-weight:600}
    .btn:hover{background:#666}
    .row{display:flex;gap:16px;align-items:center;justify-content:center}
    .stimulus{display:grid;grid-template-columns:repeat(5, minmax(60px, 120px));gap:16px;align-items:center;justify-items:center}
    .stimulus img{height:100px;width:100px;object-fit:cover;image-rendering:auto;}
    .fix{font-size:120px;line-height:1;}
    .kbdhelp{position:fixed;top:16px;left:16px;display:flex;align-items:center;gap:8px;border:2px solid #fff;padding:8px 12px;border-radius:12px;pointer-events:none;z-index:1}
    .kbdhelp img{height:28px;width:28px;object-fit:cover}
    .kbdhelp.right{left:auto;right:16px}
    .subtle{color:var(--muted);font-size:14px}
    .warn{color:var(--warn);font-weight:700}
    .hidden{display:none !important}
    .progress{height:6px;background:#222;border-radius:8px;overflow:hidden;width:min(760px,90vw)}
    .progress > div{height:100%;background:#999;width:0%}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .count{font-size:56px}
    .small{font-size:0.95rem}
    .foot{opacity:.8}
    .hide-cursor { cursor: none; }
  </style>
</head>
<body>
<div id="app"></div>

<script>
/*******************
 * CONFIG
 *******************/
const CONFIG = {
  scheduleCSV: 'flanker_schedule_mini.csv', //'flanker_schedule_4.csv',
  preloadParam: '?nf_resize=fit&w=1000',
  practiceTrials: 8,
  fixationMs: 500,
  blankMs: 500,
  timeoutMs: 2000,
  tooFastMs: 150,
  breakEvery: 1, // 50,
  breakSeconds: 10,
  showKeyCues: true,
  showProgress: false
};
instface = 'WM'

/*******************
 * STATE
 *******************/
const state = {
  screen: 'welcome',
  trials: [],
  practice: [],
  block: [],
  idx: 0,
  inPractice: true,
  awaiting: null,
  tStart: 0,
  responses: [],
  pid: new URLSearchParams(location.search).get('PID') || 'TEST',
  _timeoutTimer: null,
  _needsRequeue: false,
  _posted: false
};

/*******************
 * UTIL
 *******************/
const $ = sel => document.querySelector(sel);
const app = $('#app');

function h(tag, attrs={}, ...kids){
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
     if(k==='class') el.className = v;
     else if(k==='html') el.innerHTML = v;
     else if(/^on/.test(k) && typeof v === 'function') el[k] = v; // bind real event handler
     else el.setAttribute(k,v);
  });
  kids.flat().forEach(k=>{
     if(k==null) return;
     if(typeof k==='string') el.appendChild(document.createTextNode(k));
     else el.appendChild(k);
  });
  return el;
}

function sleep(ms){return new Promise(r=>setTimeout(r,ms));}

function download(filename, text){
  const blob = new Blob([text], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
}

function parseCSV(text){
  const rows = text.trim().split(/\r?\n/);
  const header = rows.shift().split(',').map(s=>s.trim());
  const idx = (name)=> header.indexOf(name);
  const out = [];
  for(const line of rows){
    if(!line.trim()) continue;
    const cols = line.split(',');
    const flk = (cols[idx('flanker')]||'').split(';').map(s=>s.trim());
    if(flk.length<4) continue;
    out.push({
      images: [flk[0], flk[1], (cols[idx('target')]||'').trim(), flk[2], flk[3]],
      correct: (cols[idx('correct')]||'').trim().toUpperCase(),
      congruency: (cols[idx('congruency')]||'').trim(),
      faces: (cols[idx('faces')]||'').trim(),
      type: (cols[idx('type')]||'exp').trim().toLowerCase() 
    });
  }
  return out;
}

async function preload(srcs){
  const uniq = Array.from(new Set(srcs));
  const loadOne = (src)=> new Promise(res=>{ const img=new Image(); img.onload=()=>res({src,ok:true}); img.onerror=()=>res({src,ok:false}); img.src = src + (CONFIG.preloadParam||''); });
  const results = await Promise.all(uniq.map(loadOne));
  const failed = results.filter(r=>!r.ok);
  if(failed.length){ console.warn('Failed to preload:', failed.map(f=>f.src)); }
  return results;
}

/*******************
 * RENDERERS
 *******************/
function render(){
  const s = state.screen;
  document.body.classList.toggle('hide-cursor', ['fix','blank','stim'].includes(s));
  app.innerHTML = '';

  if(CONFIG.showKeyCues && (s==='practice' || s==='main' || s==='fix' || s==='blank' || s==='stim' || s==='tooFast' || s==='tooSlow' || s==='inst1' || s==='inst2' || s==='inst3' || s==='practiceIntro')){
    app.append(
      h('div',{class:'kbdhelp'}, h('span',{class:'mono'},'Q'), ' Not emotional ', h('img',{src:'neutral_face.png',alt:'neutral'})),
      h('div',{class:'kbdhelp right'}, h('span',{class:'mono'},'P'), ' Emotional ', h('img',{src:'angry_face.png',alt:'angry'}))
    );
  }

  const container = h('div',{class:'screen'});
  app.append(container);

  if(s==='welcome'){
    container.append(
      h('h1',{},'Welcome!'),
      h('p',{},'Please read the instructions carefully. Press Continue to proceed.'),
      h('button',{class:'btn',onclick:()=>go('inst1')},'Continue')
    );
  }
  else if(s==='inst1'){
    // Congruent example above text
    container.append(
      h('div',{class:'stimulus'}, ...[0,1,2,3,4].map(()=> h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}))),
      h('h2',{style:'margin:1px 0'},'Task Instructions'),
      h('div',{},
        h('p',{style:'margin:1px 0'},'You will see five faces in a row. Your job is to judge the emotion of the ', h('b',{},'MIDDLE'), ' face only.'),
        h('p',{style:'margin:1px 0'}, h('span',{class:'mono'},'Q'),' = not emotional (neutral). ', h('span',{class:'mono'},'P'),' = emotional (e.g., angry).')
      ),
      h('button',{class:'btn',onclick:()=>go('inst2')},'Continue')
    );
  }
  else if(s==='inst2'){
    // Incongruent example above text
    container.append(
      h('div',{class:'stimulus'},
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_AC.bmp`,alt:'emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'})
      ),
      h('h2',{style:'margin:1px 0'},'Important'),
      h('p',{style:'margin:1px 0'},'Sometimes the surrounding faces will have different emotionality than the face in the middle.'),
      h('p',{style:'margin:1px 0'},'Only pay attention to the MIDDLE face!'),
      h('p',{style:'margin:1px 0'},'Press Continue to read further instruction.'),
      h('button',{class:'btn',onclick:()=>go('inst3')},'Continue')
    );
  }
  else if(s==='inst3'){
    container.append(
      h('h2',{style:'margin:1px 0'},'Examples'),
      h('p',{style:'margin:1px 0'},'In the example below, the left [Q]-key is correct:'),
      h('div',{class:'stimulus'}, ...[0,1,2,3,4].map(()=> h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}))),
      h('p',{style:'margin:1px 0'},'since the middle face is not emotional.'),
      h('p',{style:'margin:1px 0'},'In the example below, the right [P]-key is correct:'),
      h('div',{class:'stimulus'},
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_AC.bmp`,alt:'emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'}),
        h('img',{src:`/RADIATE_BMP/RADIATE_450_COLOR_BMP/${instface}/${instface}01/${instface}01_NC.bmp`,alt:'not emotional face'})
      ),
      h('p',{style:'margin:1px 0'},'since the middle face is emotional.'),
      h('p',{style:'margin:1px 0'},'Press Continue for further instruction.'),
      h('button',{class:'btn',onclick:()=>go('practiceIntro')},'Continue')
    );
  }
  else if(s==='practiceIntro'){
    container.append(
      h('h2',{},'Practice'),
      h('p',{},'Place your index fingers on ', h('b',{},'Q'),' and ', h('b',{},'P'),'. Respond as quickly and accurately as possible.'),
      h('p',{class:'subtle'},'Press Space to begin the practice block.'),
    );
  }
  else if(s==='fix'){
    container.append(h('div',{class:'fix'},'+'));
  }
  else if(s==='blank'){
    container.append(h('div',{class:'fix',style:'opacity:.0'},'+'));
  }
  else if(s==='stim'){
    const trial = currentTrial();
    container.append(
      ...(CONFIG.showProgress ? [progressBar()] : []),
      h('div',{class:'stimulus'}, ...trial.images.map((src, i)=> h('img',{src: src + (CONFIG.preloadParam||''), alt: i===2?'target':'flanker'})))
    );
  }
  else if(s==='tooFast'){
    container.append(h('div',{class:'warn'},'Too fast! Press Space to continue.'));
  }
  else if(s==='tooSlow'){
    container.append(h('div',{class:'warn'},'Too slow! Press Space to continue.'));
  }
  else if(s==='practiceBreak'){
    container.append(
      h('h2',{},'Experiment'),
      h('p',{},'Practice complete. Start the main block or practice more.'),
      h('div',{class:'row'},
        h('button',{class:'btn',onclick:startMain},'Start'),
        h('button',{class:'btn',onclick:restartPractice},'Practice More')
      )
    );
  }
  else if(s==='break'){
    container.append(h('h2',{},'Break Time!'));
    container.append(h('div',{id:'breakCount',class:'count'},''+state._breakRemaining));
    container.append(h('p',{class:'foot'},`Resuming automatically...`));
  }
  else if(s==='done'){
    ensurePosted();
    container.append(
      h('h2',{},'All done!'),
    );
  }
}

function progressBar(){
  const total = state.inPractice ? state.practice.length : state.block.length;
  const idx = state.idx;
  const pct = Math.max(0, Math.min(100, Math.round((idx/Math.max(1,total))*100)));
  const outer = h('div',{class:'progress'});
  outer.append(h('div',{style:`width:${pct}%;`}));
  return outer;
}

function currentTrial(){
  return state.inPractice ? state.practice[state.idx] : state.block[state.idx];
}

/*******************
 * FLOW
 *******************/
function go(next){
  state.screen = next;
  render();
}

async function runTrial(){
  if(state._timeoutTimer){ clearTimeout(state._timeoutTimer); state._timeoutTimer = null; }
  state.awaiting = null; go('fix'); await sleep(CONFIG.fixationMs);
  go('blank'); await sleep(CONFIG.blankMs);
  state.awaiting = 'resp';
  go('stim');
  state.tStart = performance.now();
  state._timeoutTimer = setTimeout(handleTooSlow, CONFIG.timeoutMs + 10);
}

function recordResponse(key){
  if(state._timeoutTimer){ clearTimeout(state._timeoutTimer); state._timeoutTimer = null; }
  if(state.awaiting !== 'resp') return;
  const t = currentTrial();
  const rt = performance.now() - state.tStart;
  let flag = null;
  if(rt < CONFIG.tooFastMs) flag = 'tooFast';
  else if(rt > CONFIG.timeoutMs) flag = 'tooSlow';
  const resp = {
    trial: (state.inPractice? 'P':'M') + (state.idx+1),
    response: key||null,
    rt: Math.round(rt),
    correct: key ? (key===t.correct) : false,
    congruency: t.congruency,
    faces: t.faces,
    target: t.images[2],
    pid: state.pid,
    flag,
    lapse: !!flag,
    lapseType: flag || null
  };
  state.responses.push(resp);
  if(flag==='tooFast'){ state._needsRequeue = true; state.awaiting='space'; go('tooFast'); }
  else if(flag==='tooSlow'){ state._needsRequeue = true; state.awaiting='space'; go('tooSlow'); }
  else nextTrial();
}

function requeueCurrentTrial(){
  const list = state.inPractice ? state.practice : state.block;
  if(state.idx < list.length){
    const [curr] = list.splice(state.idx, 1);
    if(curr) list.push(curr);
  }
}

function handleTooSlow(){
  if(state.awaiting !== 'resp') return;
  state.awaiting = 'space';
  const t = currentTrial();
  const resp = {
    trial: (state.inPractice? 'P':'M') + (state.idx+1),
    response: null,
    rt: CONFIG.timeoutMs,
    correct: false,
    congruency: t && t.congruency,
    faces: t && t.faces,
    target: t && t.images ? t.images[2] : null,
    pid: state.pid,
    flag: 'tooSlow',
    lapse: true,
    lapseType: 'tooSlow'
  };
  state.responses.push(resp);
  state._needsRequeue = true;
  go('tooSlow');
}

function nextTrial(){
  state.idx++;
  const total = state.inPractice ? state.practice.length : state.block.length;

  // Breaks (main block only)
  if(!state.inPractice && CONFIG.breakEvery>0 && state.idx>0 && state.idx%CONFIG.breakEvery===0 && state.idx<total){
    startBreak();
    return;
  }

  if(state.idx>=total){
    if(state.inPractice){
      state.inPractice=false; state.idx=0; go('practiceBreak');
    }else{
      go('done');
    }
  }else{
    runTrial();
  }
}

function startBreak(){
  state._breakRemaining = CONFIG.breakSeconds;
  go('break');
  state._breakTimer = setInterval(()=>{
    state._breakRemaining-=1;
    const el=$('#breakCount'); if(el) el.textContent = ''+state._breakRemaining;
    if(state._breakRemaining<=0){ clearInterval(state._breakTimer); runTrial(); }
  }, 1000);
}

function restartPractice(){
  state.inPractice = true; state.idx=0; go('practiceIntro');
}

function startMain(){
  state.inPractice = false; state.idx=0; runTrial();
}

/*******************
 * DATA IO
 *******************/
function exportData(){
  const filename = `${state.pid}_flanker.json`;
  download(filename, JSON.stringify(state.responses, null, 2));
}

// ---------------- END: send to Qualtrics ----------------
let __RG_DONE_SENT__ = false;
function sendRGDoneOnce(payload) {
  if (__RG_DONE_SENT__) return;
  __RG_DONE_SENT__ = true;
  try {
    window.parent.postMessage({ type: 'RG_DONE', payload }, '*');
    console.log('postMessage sent:', payload);
  } catch (e) {
    console.error('postMessage failed:', e);
  }
}
function endGame() {
  const results = state.responses.slice();
  const nTrials = results.length;
  const nLapses = results.filter(r => r.lapse).length;
  const rts = results.filter(r => !r.lapse && typeof r.rt === 'number').map(r => r.rt);
  const meanRT = rts.length ? Math.round(rts.reduce((a,b)=>a+b,0)/rts.length) : null;
  const nAttention = 0;
  const nAttentionPassed = 0;
  const payload = {
    task: 'flanker_faces',
    participantID: state.pid,
    results,
    summary: { nTrials, nLapses, meanRT, nAttention, nAttentionPassed }
  };
  sendRGDoneOnce(payload);
}
function ensurePosted(){ if(!state._posted){ endGame(); state._posted = true; } }
/*******************
 * INPUT HANDLERS
 *******************/
window.addEventListener('keydown', (e)=>{
  const k = e.key.toUpperCase();
  if(state.screen==='practiceIntro' && k===' '){ state.idx=0; runTrial(); }
  else if((state.screen==='tooFast'||state.screen==='tooSlow') && k===' ' && state.awaiting==='space'){
    if(state._needsRequeue){ requeueCurrentTrial(); state._needsRequeue=false; }
    state.awaiting=null; nextTrial();
  }
  else if((state.screen==='stim') && state.awaiting==='resp' && (k==='Q'||k==='P')){ recordResponse(k); }
});

/*******************
 * BOOT: LOAD SCHEDULE & PRELOAD
 *******************/
async function boot(){
  render();
  try {
    const res = await fetch(CONFIG.scheduleCSV);
    if (!res.ok) throw new Error('CSV not found');
    const text = await res.text();
    const allTrials = parseCSV(text);
    if (!allTrials || allTrials.length === 0) throw new Error('No trials parsed');
    state.trials = allTrials;
    const prac = allTrials.filter(t => t.type === 'prac');
    const exp  = allTrials.filter(t => t.type !== 'prac');  // treats missing as exp
    state.practice = CONFIG.practiceTrials ? prac.slice(0, CONFIG.practiceTrials) : prac;
    state.block = exp;
    const imgs = allTrials.flatMap(t => t.images);
    await preload(imgs);
  } catch (err) {
    console.warn('CSV/preload issue, using tiny demo set. Details:', (err && err.message) ? err.message : err);
    state.trials = [
      {images:['/RADIATE_BMP/.../WF01_NC.jpg','/RADIATE_BMP/.../WF01_NC.jpg','/RADIATE_BMP/.../WF01_NC.jpg','/RADIATE_BMP/.../WF01_NC.jpg','/RADIATE_BMP/.../WF01_NC.jpg'], correct:'Q', congruency:'congruent', faces:'neutral'},
      {images:['/RADIATE_BMP/.../WF01_NC.jpg','/RADIATE_BMP/.../WF01_NC.jpg','/RADIATE_BMP/.../WF01_AC.jpg','/RADIATE_BMP/.../WF01_NC.jpg','/RADIATE_BMP/.../WF01_NC.jpg'], correct:'P', congruency:'incongruent', faces:'angry'}
    ];
    state.practice = state.trials.slice(0,1);
    state.block = state.trials.slice(1);
  }
}
boot();
</script>
</body>
</html>
